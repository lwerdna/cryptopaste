/*
 UTF8 Encoding and Decoding

 Copyright (c) 2013-2017 Andrew Lamoureux

 This file is a part of CryptoPaste

 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation; either version 2 of the License, or (at your option) any later
 version.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 details.

 You should have received a copy of the GNU General Public License along with
 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 Place, Suite 330, Boston, MA 02111-1307 USA
*/

/*  INPUT: string to be encoded (javascript string)
   OUTPUT: encoding (array of bytes: Uint8Array) */
function utf8_encode(str)
{
	/* map the string to char codes */
	var charCodes = Array.from(str)
	charCodes = charCodes.map(function(x) { return x.charCodeAt(0) })

	/* first pass: count the bytes needed */
	var bytesNeeded = charCodes.reduce(
		function(sum, charCode) {
			if(charCode <= 0x7F) return sum+1
			if(charCode <= 0x7FF) return sum+2
			if(charCode <= 0xFFFF) return sum+3
			if(charCode <= 0x10FFFF) return sum+4
			errQuit('unexpected character code: ' + charCode + ' in utf8_encode()')
		},
		0 /* initial reduce value */
	)
	
	/* allocate the result */
	var result = new Uint8Array(bytesNeeded)

	/* map the char codes to bytes */
	var src, dst	
	for(dst=0, src=0; src < charCodes.length; ++src) {

		var cc = charCodes[src]

		if(cc <= 0x7F) {
			result[dst] = cc;
			dst += 1
		}
		else if(cc <= 0x7FF) {
			result[dst] = 0xC0 | (cc >> 6)				// 110xxxxx
			result[dst+1] = 0x80 | (cc & 0x3F)			// 10xxxxxx
			dst += 2
		}
		else if(cc <= 0xFFFF) {
			result[dst] = 0xE0 | (cc >> 12)				// 1110xxxx
			result[dst+1] = 0x80 | ((cc & 0xFC0)>>6)	// 10xxxxxx
			result[dst+2] = 0x80 | (cc & 0x3F)			// 10xxxxxx
			dst += 3
		}
		else {
			result[dst] = 0xF0 | (cc >> 18)				// 11110xxx
			result[dst+1] = 0x80 | ((cc & 0x3F000)>>12)	// 10xxxxxx
			result[dst+2] = 0x80 | ((cc & 0xFC0)>>6)	// 10xxxxxx
			result[dst+3] = 0x80 | (cc & 0x3F)			// 10xxxxxx
			dst += 4
		}
	}

	/* return the bytes */
	return result
}

/*  INPUT: Uint8Array (array of bytes)
	OUTPUT: javascript string
*/
function utf8_decode(bytes)
{
	/* first pass: count the number of char codes to allocate */
	var src, dst, numChars

	for(src=0, numChars=0; src < bytes.length; numChars += 1) {
		var b = bytes[src]
	
		if((b & 0x80) == 0)
			src += 1
		else if((b & 0xE0) == 0xC0)
			src += 2
		else if((b & 0xF0) == 0xE0)
			src += 3
		else if((b & 0xF8) == 0xF0)
			src += 4
		else
			errQuit('unexpected utf8 byte: ' + b + ' in utf8_decode()')
	}

	/* allocate the char codes */
	var charCodes = new Uint32Array(numChars)
	
	/* second pass: translate the bytes into char codes */

	for(src=0, dst=0; src < bytes.length; ++dst) {
		var b = bytes[src]
		var charCode = 0

		if((b & 0x80) == 0) {
			charCode = bytes[src]
			src += 1
		}
		else if((b & 0xE0) == 0xC0) {
			charCode = (bytes[src] & 0x1F) << 6
			charCode |= (bytes[src+1] & 0x3F)
			src += 2
		}
		else if((b & 0xF0) == 0xE0) {
			charCode = (bytes[src] & 0x0F) << 12
			charCode |= (bytes[src+1] & 0x3F) << 6
			charCode |= (bytes[src+2] & 0x3F)
			src += 3
		}
		else if((b & 0xF8) == 0xF0) {
			charCode = (bytes[src] & 0x07) << 18
			charCode |= (bytes[src+1] & 0x3F) << 12
			charCode |= (bytes[src+2] & 0x3F) << 6
			charCode |= (bytes[src+3] & 0x3F)
			src += 4
		}

		charCodes[dst] = charCode
	}

	/* map the char codes to a string */
	return String.fromCharCode.apply(null, charCodes)
}


/******************************************************************************
 TEST
******************************************************************************/
function test_utf8()
{
	/* UTF8 TESTS
		funky strings from: http://www.columbia.edu/~fdc/utf8/ */
	var str, enc

	console.log('The quick brown fox!')
	str = 'The quick brown fox jumped over the lazy dog.'
	enc = [0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x20, 0x62, 0x72, 0x6F, 0x77, 0x6E, 0x20, 0x66, 0x6F, 0x78, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x65, 0x64, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x7A, 0x79, 0x20, 0x64, 0x6F, 0x67, 0x2E]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('Laȝamon\'s Brut (The Chronicles of England, Middle English, West Midlands')
	str = 'An preost wes on leoden, Laȝamon was ihoten'
	enc = [0x41, 0x6E, 0x20, 0x70, 0x72, 0x65, 0x6F, 0x73, 0x74, 0x20, 0x77, 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x6C, 0x65, 0x6F, 0x64, 0x65, 0x6E, 0x2C, 0x20, 0x4C, 0x61, 0xC8, 0x9D, 0x61, 0x6D, 0x6F, 0x6E, 0x20, 0x77, 0x61, 0x73, 0x20, 0x69, 0x68, 0x6F, 0x74, 0x65, 0x6E]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('From the Anglo-Saxon Rune Poem (Rune version):')
	str = 'ᚠᛇᚻ᛫ᛒᛦᚦ᛫ᚠᚱᚩᚠᚢᚱ᛫ᚠᛁᚱᚪ᛫ᚷᛖᚻᚹᛦᛚᚳᚢᛗ'
	enc = [0xE1, 0x9A, 0xA0, 0xE1, 0x9B, 0x87, 0xE1, 0x9A, 0xBB, 0xE1, 0x9B, 0xAB, 0xE1, 0x9B, 0x92, 0xE1, 0x9B, 0xA6, 0xE1, 0x9A, 0xA6, 0xE1, 0x9B, 0xAB, 0xE1, 0x9A, 0xA0, 0xE1, 0x9A, 0xB1, 0xE1, 0x9A, 0xA9, 0xE1, 0x9A, 0xA0, 0xE1, 0x9A, 0xA2, 0xE1, 0x9A, 0xB1, 0xE1, 0x9B, 0xAB, 0xE1, 0x9A, 0xA0, 0xE1, 0x9B, 0x81, 0xE1, 0x9A, 0xB1, 0xE1, 0x9A, 0xAA, 0xE1, 0x9B, 0xAB, 0xE1, 0x9A, 0xB7, 0xE1, 0x9B, 0x96, 0xE1, 0x9A, 0xBB, 0xE1, 0x9A, 0xB9, 0xE1, 0x9B, 0xA6, 0xE1, 0x9B, 0x9A, 0xE1, 0x9A, 0xB3, 0xE1, 0x9A, 0xA2, 0xE1, 0x9B, 0x97]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('From the Tagelied of Wolfram von Eschenbach (Middle High German):')
	str = 'Sîne klâwen durh die wolken sint geslagen'
	enc = [0x53, 0xC3, 0xAE, 0x6E, 0x65, 0x20, 0x6B, 0x6C, 0xC3, 0xA2, 0x77, 0x65, 0x6E, 0x20, 0x64, 0x75, 0x72, 0x68, 0x20, 0x64, 0x69, 0x65, 0x20, 0x77, 0x6F, 0x6C, 0x6B, 0x65, 0x6E, 0x20, 0x73, 0x69, 0x6E, 0x74, 0x20, 0x67, 0x65, 0x73, 0x6C, 0x61, 0x67, 0x65, 0x6E]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('Some lines of Odysseus Elytis (Greek):')
	str = 'Τη γλώσσα μου έδωσαν ελληνική'
	enc = [0xCE, 0xA4, 0xCE, 0xB7, 0x20, 0xCE, 0xB3, 0xCE, 0xBB, 0xCF, 0x8E, 0xCF, 0x83, 0xCF, 0x83, 0xCE, 0xB1, 0x20, 0xCE, 0xBC, 0xCE, 0xBF, 0xCF, 0x85, 0x20, 0xCE, 0xAD, 0xCE, 0xB4, 0xCF, 0x89, 0xCF, 0x83, 0xCE, 0xB1, 0xCE, 0xBD, 0x20, 0xCE, 0xB5, 0xCE, 0xBB, 0xCE, 0xBB, 0xCE, 0xB7, 0xCE, 0xBD, 0xCE, 0xB9, 0xCE, 0xBA, 0xCE, 0xAE]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('The first stanza of Pushkin\'s Bronze Horseman (Russian):')
	str = 'На берегу пустынных волн'
	enc = [0xD0, 0x9D, 0xD0, 0xB0, 0x20, 0xD0, 0xB1, 0xD0, 0xB5, 0xD1, 0x80, 0xD0, 0xB5, 0xD0, 0xB3, 0xD1, 0x83, 0x20, 0xD0, 0xBF, 0xD1, 0x83, 0xD1, 0x81, 0xD1, 0x82, 0xD1, 0x8B, 0xD0, 0xBD, 0xD0, 0xBD, 0xD1, 0x8B, 0xD1, 0x85, 0x20, 0xD0, 0xB2, 0xD0, 0xBE, 0xD0, 0xBB, 0xD0, 0xBD]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	console.log('Šota Rustaveli\'s Veṗxis Ṭq̇aosani, ̣︡Th, The Knight in the Tiger\'s Skin (Georgian):')
	str = 'ვეპხის ტყაოსანი შოთა რუსთაველი'
	enc = [0xE1, 0x83, 0x95, 0xE1, 0x83, 0x94, 0xE1, 0x83, 0x9E, 0xE1, 0x83, 0xAE, 0xE1, 0x83, 0x98, 0xE1, 0x83, 0xA1, 0x20, 0xE1, 0x83, 0xA2, 0xE1, 0x83, 0xA7, 0xE1, 0x83, 0x90, 0xE1, 0x83, 0x9D, 0xE1, 0x83, 0xA1, 0xE1, 0x83, 0x90, 0xE1, 0x83, 0x9C, 0xE1, 0x83, 0x98, 0x20, 0xE1, 0x83, 0xA8, 0xE1, 0x83, 0x9D, 0xE1, 0x83, 0x97, 0xE1, 0x83, 0x90, 0x20, 0xE1, 0x83, 0xA0, 0xE1, 0x83, 0xA3, 0xE1, 0x83, 0xA1, 0xE1, 0x83, 0x97, 0xE1, 0x83, 0x90, 0xE1, 0x83, 0x95, 0xE1, 0x83, 0x94, 0xE1, 0x83, 0x9A, 0xE1, 0x83, 0x98]
	assert(!u8cmp(utf8_encode(str), enc))
	assert(utf8_decode(enc) == str)

	/* could not include tests for:
		Tamil poetry of Subramaniya Bharathiyar or
		Kannada poetry by Kuvempu

		'cause they fucked up VIM
	*/
}
